---
globs: **/*spotify*,**/*api*
description: Spotify API integration patterns and best practices
---

# Spotify API Integration Standards

## Authentication Flow
```typescript
// OAuth2 Configuration
export const SPOTIFY_CONFIG = {
  clientId: process.env.SPOTIFY_CLIENT_ID!,
  clientSecret: process.env.SPOTIFY_CLIENT_SECRET!,
  redirectUri: process.env.SPOTIFY_REDIRECT_URI!,
  scopes: [
    'playlist-read-private',
    'playlist-read-collaborative',
    'playlist-modify-public',
    'playlist-modify-private',
    'user-read-private',
  ],
} as const;

// Authorization URL generation
export function generateAuthUrl(state: string): string {
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: SPOTIFY_CONFIG.clientId,
    scope: SPOTIFY_CONFIG.scopes.join(' '),
    redirect_uri: SPOTIFY_CONFIG.redirectUri,
    state,
  });
  
  return `https://accounts.spotify.com/authorize?${params.toString()}`;
}
```

## Token Management
```typescript
interface SpotifyTokens {
  accessToken: string;
  refreshToken: string;
  expiresAt: number;
  scope: string;
}

class TokenManager {
  private tokens: SpotifyTokens | null = null;

  async getValidToken(): Promise<string> {
    if (!this.tokens || this.isTokenExpired()) {
      await this.refreshToken();
    }
    return this.tokens!.accessToken;
  }

  private isTokenExpired(): boolean {
    return Date.now() >= this.tokens!.expiresAt;
  }

  private async refreshToken(): Promise<void> {
    if (!this.tokens?.refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': `Basic ${Buffer.from(
          `${SPOTIFY_CONFIG.clientId}:${SPOTIFY_CONFIG.clientSecret}`
        ).toString('base64')}`,
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: this.tokens.refreshToken,
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to refresh token');
    }

    const data = await response.json();
    this.tokens = {
      accessToken: data.access_token,
      refreshToken: this.tokens.refreshToken,
      expiresAt: Date.now() + data.expires_in * 1000,
      scope: data.scope,
    };
  }
}
```

## API Client
```typescript
class SpotifyApiClient {
  private baseUrl = 'https://api.spotify.com/v1';
  private tokenManager: TokenManager;

  constructor(tokenManager: TokenManager) {
    this.tokenManager = tokenManager;
  }

  private async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const token = await this.tokenManager.getValidToken();
    
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      throw new SpotifyApiError(
        `API request failed: ${response.statusText}`,
        response.status,
        endpoint
      );
    }

    return response.json();
  }

  async getUserPlaylists(limit = 50, offset = 0): Promise<SpotifyPlaylist[]> {
    const data = await this.makeRequest<{
      items: SpotifyPlaylist[];
      total: number;
    }>(`/me/playlists?limit=${limit}&offset=${offset}`);
    
    return data.items;
  }

  async getPlaylistTracks(
    playlistId: string,
    limit = 100,
    offset = 0
  ): Promise<SpotifyTrack[]> {
    const data = await this.makeRequest<{
      items: Array<{ track: SpotifyTrack }>;
    }>(`/playlists/${playlistId}/tracks?limit=${limit}&offset=${offset}`);
    
    return data.items.map(item => item.track).filter(track => track !== null);
  }

  async createPlaylist(
    userId: string,
    name: string,
    description?: string,
    public = false
  ): Promise<SpotifyPlaylist> {
    return this.makeRequest<SpotifyPlaylist>(`/users/${userId}/playlists`, {
      method: 'POST',
      body: JSON.stringify({
        name,
        description,
        public,
      }),
    });
  }

  async addTracksToPlaylist(
    playlistId: string,
    trackUris: string[]
  ): Promise<void> {
    await this.makeRequest(`/playlists/${playlistId}/tracks`, {
      method: 'POST',
      body: JSON.stringify({
        uris: trackUris,
      }),
    });
  }
}
```

## Type Definitions
```typescript
export interface SpotifyPlaylist {
  id: string;
  name: string;
  description: string;
  public: boolean;
  collaborative: boolean;
  owner: {
    id: string;
    display_name: string;
  };
  tracks: {
    href: string;
    total: number;
  };
  images: Array<{
    url: string;
    height: number;
    width: number;
  }>;
}

export interface SpotifyTrack {
  id: string;
  name: string;
  artists: Array<{
    id: string;
    name: string;
  }>;
  album: {
    id: string;
    name: string;
    images: Array<{
      url: string;
      height: number;
      width: number;
    }>;
  };
  duration_ms: number;
  external_urls: {
    spotify: string;
  };
}

export interface SpotifyUser {
  id: string;
  display_name: string;
  email: string;
  images: Array<{
    url: string;
    height: number;
    width: number;
  }>;
}
```

## Error Handling
```typescript
export class SpotifyApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public endpoint: string,
    public retryAfter?: number
  ) {
    super(message);
    this.name = 'SpotifyApiError';
  }

  static fromResponse(response: Response, endpoint: string): SpotifyApiError {
    const retryAfter = response.headers.get('Retry-After');
    return new SpotifyApiError(
      `Spotify API error: ${response.statusText}`,
      response.status,
      endpoint,
      retryAfter ? parseInt(retryAfter) : undefined
    );
  }
}

// Rate limiting handler
export class RateLimitHandler {
  private retryAfter: number | null = null;

  async handleRateLimit(error: SpotifyApiError): Promise<void> {
    if (error.statusCode === 429) {
      this.retryAfter = error.retryAfter || 60;
      await this.waitForRetry();
    } else {
      throw error;
    }
  }

  private async waitForRetry(): Promise<void> {
    if (this.retryAfter) {
      await new Promise(resolve => 
        setTimeout(resolve, this.retryAfter! * 1000)
      );
      this.retryAfter = null;
    }
  }
}
```

## Playlist Merging Logic
```typescript
export class PlaylistMerger {
  constructor(private apiClient: SpotifyApiClient) {}

  async mergePlaylists(
    sourcePlaylistIds: string[],
    targetPlaylistId: string
  ): Promise<{ addedTracks: number; skippedTracks: number }> {
    const allTracks = new Map<string, SpotifyTrack>();
    
    // Fetch tracks from all source playlists
    for (const playlistId of sourcePlaylistIds) {
      const tracks = await this.getAllPlaylistTracks(playlistId);
      tracks.forEach(track => {
        if (track.id) {
          allTracks.set(track.id, track);
        }
      });
    }

    // Get existing tracks in target playlist
    const existingTracks = await this.getAllPlaylistTracks(targetPlaylistId);
    const existingTrackIds = new Set(existingTracks.map(t => t.id));

    // Filter out tracks that already exist
    const newTracks = Array.from(allTracks.values()).filter(
      track => !existingTrackIds.has(track.id)
    );

    // Add new tracks to target playlist
    if (newTracks.length > 0) {
      const trackUris = newTracks.map(track => `spotify:track:${track.id}`);
      await this.apiClient.addTracksToPlaylist(targetPlaylistId, trackUris);
    }

    return {
      addedTracks: newTracks.length,
      skippedTracks: allTracks.size - newTracks.length,
    };
  }

  private async getAllPlaylistTracks(playlistId: string): Promise<SpotifyTrack[]> {
    const allTracks: SpotifyTrack[] = [];
    let offset = 0;
    const limit = 100;

    while (true) {
      const tracks = await this.apiClient.getPlaylistTracks(
        playlistId,
        limit,
        offset
      );
      
      if (tracks.length === 0) break;
      
      allTracks.push(...tracks);
      offset += limit;
    }

    return allTracks;
  }
}
```

## Caching Strategy
```typescript
export class SpotifyCache {
  private cache = new Map<string, { data: any; expiresAt: number }>();
  private defaultTtl = 5 * 60 * 1000; // 5 minutes

  set(key: string, data: any, ttl = this.defaultTtl): void {
    this.cache.set(key, {
      data,
      expiresAt: Date.now() + ttl,
    });
  }

  get<T>(key: string): T | null {
    const item = this.cache.get(key);
    if (!item || Date.now() > item.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    return item.data as T;
  }

  clear(): void {
    this.cache.clear();
  }
}
```